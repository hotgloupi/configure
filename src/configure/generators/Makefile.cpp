#include "Makefile.hpp"

#include <configure/BuildGraph.hpp>
#include <configure/Build.hpp>
#include <configure/Command.hpp>
#include <configure/Filesystem.hpp>
#include <configure/Graph.hpp>
#include <configure/quote.hpp>
#include <configure/utils/path.hpp>
#include <configure/PropertyMap.hpp>
#include <configure/log.hpp>
#include <configure/Rule.hpp>
#include <configure/ShellCommand.hpp>
#include <configure/error.hpp>

#include <boost/algorithm/string/join.hpp>
#include <boost/filesystem.hpp>

#include <fstream>
#include <unordered_set>

namespace configure { namespace generators {

	Makefile::Makefile(Build& build,
	                   path_t project_directory,
	                   path_t configure_exe,
	                   char const* name)
		: Generator(
			build,
			std::move(project_directory),
			std::move(configure_exe),
			(name == nullptr ? Makefile::name() : name)
		)
	{}

	std::string Makefile::node_path(Node& node) const
	{
		std::string res;
		if (this->use_relative_path())
			res = node.relative_path(_build.directory()).string();
		else
			res = node.path().string();
		return quote_arg(this->command_parser(), res);
	}

	CommandParser Makefile::command_parser() const
	{ return CommandParser::make; }

	void Makefile::prepare()
	{
		BuildGraph const& bg = _build.build_graph();
		Graph const& g = bg.graph();

		{
			Rule regen;
			regen.add_target(_build.target_node("Makefile"));
			for (auto& project_dir: _build.configured_projects())
			{
				auto p = Build::find_project_file(project_dir);
				auto& n = _build.source_node(p);
				regen.add_source(n);
			}
			ShellCommand regen_cmd;
			regen_cmd.append(
				_build.target_node(_configure_exe),
				"--project", _build.configured_projects().at(0),
				_build.directory()
			);
			regen.add_shell_command(std::move(regen_cmd));
			//ShellCommand make_cmd;
			//make_cmd.extend(this->build_command("all"));
			//regen.add_shell_command(std::move(make_cmd));
			_build.add_rule(std::move(regen));
		}


		for (auto vertex_range = boost::vertices(g);
		     vertex_range.first != vertex_range.second;
		     ++vertex_range.first)
		{
			auto vertex = *vertex_range.first;
			auto& node = bg.node(vertex);

			if (node->is_virtual())
			{
				if (node->name().empty())
					continue;
				_virtual_nodes.push_back(node);
			}
			else
			{
				// Check for nodes that are not generated by us (no inputs).
				// (this does not apply to virtual nodes, that always
				// considered as targets).
				auto in_edge_range = boost::in_edges(vertex, g);
				if (in_edge_range.first == in_edge_range.second)
				{
					_sources.push_back(node);
					continue;
				}
			}

			// At this point we know that the node is a target.
			_targets.push_back(node);

			auto out_edge_range = boost::out_edges(vertex, g);
			if (out_edge_range.first == out_edge_range.second)
			{
				// Nothing depends on this node, this target is final.
				if (!node->is_virtual())
					_final_targets.push_back(node);
			}
			else
			{
				// Something depends on this Node, it is a also a source.
				if (!node->is_virtual())
					_sources.push_back(node);

				// The node is still considered final if the root node depends
				// on it.
				if (bg.has_link(*_build.root_node(), *node))
					_final_targets.push_back(node);
			}
		}

		for (auto& node: _sources)
		{
			if (!node->is_file() || !node->has_property("language"))
				continue;

			auto& lang = node->property<std::string>("language");
			if (lang == "c" || lang == "c++")
			{
				auto include_directories = node->property<std::vector<boost::filesystem::path>>("include_directories");
				NodePtr first_target;
				for (auto out_edge_range = boost::out_edges(node->index, g);
					 out_edge_range.first != out_edge_range.second;
					 ++out_edge_range.first)
				{
					first_target = bg.node(boost::target(*out_edge_range.first, g));
					break;
				}
				if (first_target == nullptr)
				{
					log::warning("Ignore implicit dependencies for",
					             node->string(), ", no target node found...");
					continue;
				}

				auto& target = _build.target_node(
					first_target->relative_path(_build.directory()).string() + ".mk"
				);
				_includes.push_back(target);
				ShellCommand cmd;
				cmd.append(
					_configure_exe, "-E" , "c-header-dependencies",
					target, node
				);
				for (auto out_edge_range = boost::out_edges(node->index, g);
					 out_edge_range.first != out_edge_range.second;
					 ++out_edge_range.first)
				{
					// We link as a dependency of then command outputs
					auto obj = bg.node(boost::target(*out_edge_range.first, g));
					_build.add_rule(Rule().add_source(target).add_target(obj));
					cmd.append(std::move(obj));
				}
				cmd.append("--");
				for (auto& dir: include_directories)
				{
					if (utils::starts_with(dir, _project_directory))
						cmd.append(_build.directory_node(dir));
				}
				_build.add_rule(
					Rule()
						.add_source(node)
						.add_target(target)
						.add_shell_command(std::move(cmd))
				);
			}
		}

		// We still need to add dependencies to the final targets
		for (auto& node: _includes)
			_targets.push_back(node);
	}

	namespace {

		struct RelativePathShellFormatter
			: public ShellFormatter
		{
			boost::filesystem::path const& _build_dir;
			boost::filesystem::path const& _project_dir;

			RelativePathShellFormatter(Build& build,
			                           boost::filesystem::path const& project_dir)
				: ShellFormatter(build)
				, _build_dir(build.directory())
				, _project_dir(project_dir)
			{}

			std::string
			operator()(ShellCommand const& command,
				       boost::filesystem::path const& value) const override
			{
				if (command.has_working_directory() &&
				    utils::starts_with(value, _project_dir))
					return utils::relative_path(
					  value, command.working_directory()).string();
				if (utils::starts_with(value, _project_dir))
					return utils::relative_path(value, _build_dir).string();
				return value.string();
			}
		};

	}

	void Makefile::generate() const
	{
		bool use_relpath = _build.option<bool>(
		    "GENERATOR_" + std::string(_name) + "_USE_RELATIVE_PATH",
		    std::string(_name) + " generator uses relative path",
		    this->use_relative_path()
		);
		std::unique_ptr<ShellFormatter> formatter;
		if (use_relpath)
			formatter = std::unique_ptr<ShellFormatter>(
				new RelativePathShellFormatter(_build, _project_directory)
			);
		else
			formatter = std::unique_ptr<ShellFormatter>(new ShellFormatter(_build));

		auto& makefile_node = _build.target_node("Makefile");
		std::ofstream out(makefile_node->path().string());
		out << "# Generated " << _name << std::endl;
		if (_name == "Makefile")
		{
			// This speed up the makefile
			out << "MAKEFLAGS += --no-builtin-rules" << std::endl;
			out << ".SUFFIXES:" << std::endl;
		}
		BuildGraph const& bg = _build.build_graph();
		Graph const& g = bg.graph();

		// Fill the "all" and ".PHONY" rules
		out << ".PHONY:" << std::endl;
		out << ".PHONY: all";
		for (auto node: _virtual_nodes)
			out << ' ' << node->name();
		out << "\n\n";

		if (!_final_targets.empty())
		{
			out << "all:";
			for (auto& node: _final_targets)
			{
				if (node->is_file())
					out << ' ' << node_path(*node);
				else if (node->is_virtual() && !node->name().empty())
					out << ' ' << node->name();
			}
			out << "\n\n";

			out << "clean:\n";
			for (auto& node: _targets)
				if (node->is_file())
					out << '\t' << "rm -f " << node_path(*node) << '\n';
			out << "\n";
		}

		auto generated_commands_property_name =
			std::string(this->name()) + "_GENERATED_COMMANDS";
		std::unordered_set<Node const*> to_delete;
		for (auto& node: _targets)
		{
			if (node->is_virtual())
				out << node->name() << ':';
			else
				out << node_path(*node) << ':';

			auto in_edge_range = boost::in_edges(node->index, g);
			for (GraphTraits::in_edge_iterator i = in_edge_range.first;
			     i != in_edge_range.second; ++i)
			{
				auto node = bg.node(boost::source(*i, g)).get();
				if (node->is_file())
					out << ' ' << node_path(*node);
				else if (node->is_virtual())
					out << ' ' << node->name();
			}
			out << std::endl;

			std::vector<std::string> command_strings;
			std::unordered_set<Command const*> seen_commands;
			for (; in_edge_range.first != in_edge_range.second;
			     ++in_edge_range.first)
			{
				auto& link = bg.link(*in_edge_range.first);
				Command const* cmd_ptr = &link.command();
				if (seen_commands.insert(cmd_ptr).second == false)
					continue;
				for (auto const& shell_command: cmd_ptr->shell_commands())
				{
					command_strings.push_back(
						this->dump_command(shell_command, link, *formatter)
					);
					out << '\t' << command_strings.back() << std::endl;
				}
			}
			out << std::endl;
			if (node->is_file())
			{
				bool had_commands_property = node->has_property(
					generated_commands_property_name
				);
				auto new_command = boost::join(command_strings, "\n");
				if (had_commands_property && node != makefile_node)
				{
					auto& old_command = node->property<std::string>(generated_commands_property_name);
				    if (old_command != new_command)
					{
						log::verbose("Deleting node", node->string(),
						             "(command line changed: ", old_command,
						             "->", new_command, ")");
						to_delete.insert(node.get());
					}
				}
				node->set_property<std::string>(
					generated_commands_property_name,
					new_command
				);
			}
		}

		for (auto node: to_delete)
		{
			try {
				boost::filesystem::remove(node->path());
			} catch (...) {
				log::warning("Couldn't remove", node->string(), ":", error_string());
			}
		}
		this->include_dependencies(out, use_relpath);
	}

	void Makefile::include_dependencies(std::ostream& out, bool relative) const
	{
		if (relative)
			for (auto& node: _includes)
				out << "-include " << node_path(*node) << std::endl;
		else
			for (auto& node: _includes)
				out << "-include " << node_path(*node) << std::endl;
	}

	std::string Makefile::dump_command(ShellCommand const& cmd,
	                                   DependencyLink const& link,
	                                   ShellFormatter const& formatter) const
	{
		std::string res;

		if (cmd.has_working_directory())
		{
			ShellCommand chdir;
			chdir.append("cd", cmd.working_directory());
			res += quote<CommandParser::make>(chdir.string(_build, link, formatter)) + " && ";
		}
		if (cmd.has_env())
		{
			for (auto& pair: cmd.env())
				res += pair.first + "=" + pair.second + " ";
		}
		auto cmd_args = cmd.string(_build, link, formatter);
		std::string cmd_str = quote<CommandParser::make>(cmd_args);
#ifdef _WIN32
		if (cmd_args.size() == 1)
		{
			// Workaroung a bug in GNU Make, when commands contain a double quote
			// they are spawned through CreateProcess() as 'sh -c \"COMMAND HERE\"'
			// when the argument does have any special character other than slash
			// and there is only one argument, quotes are left ...
			if (cmd_str[0] == '"' && cmd_str.back() == '"' )
			{
				cmd_str = cmd_str.substr(1, cmd_str.size() - 2);
			}
		}
#endif
		return res + cmd_str;
	}

	bool Makefile::is_available(Build& build)
	{ return build.fs().which("make") != boost::none; }

	std::vector<std::string>
	Makefile::build_command(std::string const& target) const
	{
		return {
			"make", "-C", _build.directory().string(),
			target.empty() ? "all" : target
		};
	}

	bool Makefile::use_relative_path() const { return true; }
}}

